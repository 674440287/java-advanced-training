# 串行GC（Serial GC）
串行GC 对年轻代使用 mark-copy（标记-复制）算法，对老年代使用mark-sweep-compact（标记-清楚-整理）算法。
两者都是单线程垃圾收集器，不能并行处理，所以都会触发全线暂停（STW），停止所有的应用线程。因此这种GC算法不能充分利用多核CPU，不管有多少个CPU，jvm在垃圾回收的时候都只能使用单个核心。
对于服务器端应用部署到多核平台上，选择串行GC就意味人为的限制了垃圾回收器对系统资源的使用，会导致GC停顿时间过长。无法充分利用CPU

## 串行GC的堆内存分布式基于

### 分代假设

研究人员发现，程序中大多数可回收的内存可归为两类
1. 大部分对象很快就不再使用，生命周期很短
2. 还有一部分不会立即无用，但也不会持续太长时间
这种观测形成了弱代假设，即我们可以根据对象的不同特点，把对象进行分类，基于这一假设，vm中的内存被分为年轻代和老年代。根据对象的不同特点，允许采用不同的GC策略来提升GC性能。分代假设专门针对“要么死得快，否则活得长”这类特性的对象来进行优化，此时jvm管理那种存活时间半长不长的对象就显得非常尴尬了

### 内存池划分
1. Eden space，内存中一个区域，用来分配新创建的对象，通常会有多个线程同时创建多个对象，所以Eden区被划分为多个线程本地分配缓冲区（Thread Local Allocation Buffer 简称TLAB）通过这种缓存区划分，大部分对象直接由JVM在对应的线程的TLAB中分配，避免与其他线程的同步操作。
2. 如果TLAB中没有足够的内存就会在共享Eden区进行分配，如果共享Eden区也没有足够空间，就会触发一次年轻代GC来释放内存空间，如果GC之后Eden区依然没有足够的空闲空间内存区域，则对象就会被分配到老年代空间。

当Eden区进行垃圾回收的时候，GC将所有从root可达的对象过一遍，并标记为存活对象
对象间可能会有跨代引用，所以需要一种方法来标记从其他分代指向Eden的所有引用，这样做又会遭遇各个分代之间一遍又一遍的引用，jvm在实现时采用了一些绝招，卡片标记（card-marking），从本质上讲jvm只需要记住eden区中“脏”对象的粗略位置，可能有老年代的对象指向这部分区间。
标记阶段完成后，Eden区中所有存活的对象都会被粉知道存活区中，这种方法称为“标记-复制”方法（mark and copy）