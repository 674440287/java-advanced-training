# 串行GC（Serial GC）
串行GC 对年轻代使用 mark-copy（标记-复制）算法，对老年代使用mark-sweep-compact（标记-清楚-整理）算法。
两者都是单线程垃圾收集器，不能并行处理，所以都会触发全线暂停（STW），停止所有的应用线程。因此这种GC算法不能充分利用多核CPU，不管有多少个CPU，jvm在垃圾回收的时候都只能使用单个核心。
对于服务器端应用部署到多核平台上，选择串行GC就意味人为的限制了垃圾回收器对系统资源的使用，会导致GC停顿时间过长。无法充分利用CPU

## 串行GC的堆内存分布基于分代假设

### 分代假设

研究人员发现，程序中大多数可回收的内存可归为两类
1. 大部分对象很快就不再使用，生命周期很短
2. 还有一部分不会立即无用，但也不会持续太长时间
这种观测形成了弱代假设，即我们可以根据对象的不同特点，把对象进行分类，基于这一假设，vm中的内存被分为年轻代和老年代。根据对象的不同特点，允许采用不同的GC策略来提升GC性能。分代假设专门针对“要么死得快，否则活得长”这类特性的对象来进行优化，此时jvm管理那种存活时间半长不长的对象就显得非常尴尬了

### 内存池划分
1. Eden space
   1. 内存中一个区域，用来分配新创建的对象，通常会有多个线程同时创建多个对象，所以Eden区被划分为多个线程本地分配缓冲区（Thread Local Allocation Buffer 简称TLAB）通过这种缓存区划分，大部分对象直接由JVM在对应的线程的TLAB中分配，避免与其他线程的同步操作。
   2. 如果TLAB中没有足够的内存就会在共享Eden区进行分配，如果共享Eden区也没有足够空间，就会触发一次年轻代GC来释放内存空间，如果GC之后Eden区依然没有足够的空闲空间内存区域，则对象就会被分配到老年代空间。
   3. 当Eden区进行垃圾回收的时候，GC将所有从root可达的对象过一遍，并标记为存活对象
   4. 对象间可能会有跨代引用，所以需要一种方法来标记从其他分代指向Eden的所有引用，这样做又会遭遇各个分代之间一遍又一遍的引用，jvm在实现时采用了一些绝招，卡片标记（card-marking），从本质上讲jvm只需要记住eden区中“脏”对象的粗略位置，可能有老年代的对象指向这部分区间。
   5. 标记阶段完成后，Eden区中所有存活的对象都会被粉知道存活区中，这种方法称为“标记-复制”方法（mark and copy）
2. Survivor spaces
   1. Eden区旁边有两个存活区，成为from 空间和to 空间，需要强调的饿是任意时刻总有一个存活区是空的。
   2. 空的那个存活区用于在下次年轻代GC时存放收集的对象
   3. 存活的对象会在两个存活区之间复制多次，直到某些对象的存活时间达到一定的阈值，分代理论假设，存活超过一定时间的对象那个很可能会继续存活更长时间。
3. Old Gen
   1. 老年代的GC实现要复杂的多，老年代的内存空间通常会更大，里面的对象是垃圾的概率更小
   2. 老年代发生GC的频率比年轻代小得多，同时因为预期老年代中绝大多数对象是存活的，所以不再使用标记复制算法，而是采用移动对象的方式来最小化内存碎片，老年代空间的清理算法通常建立在不同的基础上面，原则上会执行一下步骤
      1. 标记可达对象
      2. 删除所有不可达
      3. 整理空间，将存活对象复制，从老年代空间开始的地方依次存放。

# 并行GC（Parallel GC）
并行垃圾回收器这一类租户，在年轻代使用标记复制算法（mark-copy），在老年代使用标记清除整理算法（mark-sweep-compact），年轻代和老年代的垃圾回收都会触发stw事件，暂停所有应用线程来执行垃圾收集，两者在执行标记和复制/整理阶段都会使用多个线程，因此得名（parallel）通过并行执行，使得GC时间大幅减少。
并行垃圾回收器适用于多核服务器，主要目标是增加吞吐量，因为对系统资源的有效利用，能够达到更好的吞吐量
1. 在gc期间，所有cpu内核都在并行清理垃圾，所以总暂停时间更短
2. 在两次GC周期的间隔期，没有gc线程在运行，不会消耗任何系统资源

# cms 垃圾收集器（Mostly Concurrent Mark and Sweep Garbage Collector）
年轻代采用并行STW方式的mark-copy算法，对老年代使用并发mark-sweep算法。
CMS GC设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标
1. 不对老年代进行整理，使用空闲列表来管理内存空间的回收
2. 在mark-and-sweep阶段的大部分工作和应用线程一起并发执行
默认情况cms 使用的线程数等于cpu 核心数的1/4

cms gc 比并行gc 的吞吐量差一些，在实际情况下，进行老年代的并发回收时候，可能会伴随所赐年轻代的minor gc，在这种情况下full gc的日志中会掺杂多次minor gc事件。

## cms 的几个阶段
1. Initial Mark 初始化标记
   1. 这个阶段伴随着STW暂停，初始化标记的目标是标记所有根对象，包括根对象直接引用的对象，以及被年轻代中所有存活对象所以用的对象。
2. Concurrent 并发标记
   1. CMS GC遍历老年代，标记所有存活的对象，从前一阶段initial mark找到的根对象开始算起，并发标记阶段，就是与应用程序同时运行，不用暂停的阶段，请注意，并非所有老年代中存活的对象都在此阶段被标记，因为标记过程中对象的引用关系还在变化。
3. Concurrent preclean 并发预清理
   1. 此阶段同样是与应用线程并发执行的，不需要停止应用线程
   2. 因为前一阶段并发标记，与程序并发运行，可能有一些引用关系已经发生了改变，如果在并发标记过程中引用关系发生了变化，JVM会通过 card 卡片的方式将发生了改变的区域标记为脏区，这就是所谓的卡片标记
   3. 在预清理阶段，这些脏对象会被统计出来，他们所引用的对象也会被标记，此阶段完成后，用以编辑的card也会被清空
4. concurrent abortable preclean 可取消的并发预清理
   1. 此阶段也不停止应用线程，本阶段尝试在stw 的final remark阶段之间尽可能地多做一些工作，本阶段具体时间取决于多种隐私，因为他循环做同样的事情，知道满足某个退出条件，如迭代次数，有用工作量，消耗的系统时间
5. final remark 最终标记
   1. 最终标记阶段是此次gc事件中的第二次stw 停顿
   2. 本阶段的目标送hi完成老年代中所有存活对象的标记，因为之前的预清理阶段是并发执行的，有可能gc线程跟不上应用线程的修改速度，所以需要一次stw暂停来处理各种复杂的情况
   3. 通常cms 会尝试在年轻代尽可能空的情况下执行final remark阶段，以免连续触发多次stw事件
6. concurrent sweep 并发清除
7. concurrent reset

# Garbage-First 垃圾收集器
1. G1 GC最主要的设计目标是：将STW停顿的时间和分布，变成可预期且可配置的
2. 实时上G1 GC 是一款软实时垃圾收集器，可以为其设置某项特定的性能指标，例如可以指定在任务xx毫秒时间范围内，stw停顿时间不得超过yy毫秒，举例说明：任意1秒内暂停时间不超过5ms，g1 gc 会尽力达成这个目标，有很大概率会满足，但并不完全确定
3. G1 GC特点
   1. 为了达成可预期停顿时间的指标，g1 gc 有一些独特的实现
   2. 首先，堆不在分成年轻代和老年代，而是划分为**多个（通常是2048个）可以存放对象的小块堆区域（smaller heap regions）**。每个小块，可能一会被定义成Eden区，一会被指定为servivor区或者old 区，在逻辑上，所有的eden区和survivor区合起来就是年轻代，所有的old区拼在一起就是老年代。这样划分之后，使得g1不必每次都去收集整个堆空间，而是以增量的方式来进行处理，每次只处理一部分内存块，称为此次gc的回收集，每次gc暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存快。
   4. gc的另一项创新是在**并发阶段估计每个小堆块存活对象的总数**，构建回收集原则是：垃圾最多的小块会被优先收集，这也是g1名称的由来
4. g1 gc核心参数
   1. -XX:+UserG1GC 启用G1GC
   2. -XX:+InitiatingHeapOccupancyPercent：决定什么情况下发生G1 GC
   3. -XX:MaxGCPauseMills: 期望每次GC的暂停时间。
5. 年轻代模式转移暂停（Evacuation Pause）
   1. 通过前面的分析可以看到，G1GC会通过前面一段时间的运行情况不断的调整自己的回收策略和行为，以此来比较稳定的控制暂停时间，在应用程序刚启动时，g1还没有采集到什么足够的信息，这时候就处于初始的fully-young 模式，当年轻代空间用满之后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活区，如果还没有存活区，则任意选择一部分空闲的内存块作为存活区
   2. 拷贝的过程称为转移（Evacuation）这和前面介绍的其他年轻代收集器是一样的工作原理
6. 并发标记（Concurrent Marking）
   1. 同时我们也看到，G1GC的很多概念建立在CMS的基础上
   2. G1并发标记的过程与CMS基本上是一样的，G1的并发标记通过snapshot-At-The-Beginning（起始快照）的方式，在标记阶段开始时记下所有的存活对象，即使在标记的同时又有一些变成了垃圾，通过对象的存活信息，可以构建出每个小堆块的存货状态，以便回收集能高效的进行选择